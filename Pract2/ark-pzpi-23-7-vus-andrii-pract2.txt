Міністерство освіти та науки України
Харківський національний університет радіоелектроніки

Кафедра ПІ




ЗВІТ
з практичного заняття №2
з дисципліни «Аналіз та Рефакторинг Коду»
на тему «Методи рефакторингу коду програмного забезпечення»






Виконав:                                                                               Прийняв:
ст. гр. ПЗПІ-23-7                                                                  ст. викл. кат. ПІ
Вус Андрій Миколайович                                                   Сокорчук Ігор Петрович









Харків 2025
1 ІСТОРІЯ ЗМІН 

№	Дата	Версія звіту	Опис змін та виправлень
1	14.11.2025	1.0	Створено та повністю оформлено звіт

 
2 ЗАВДАННЯ

Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code» [1].
Необхідно навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів.
Кожен метод рефакторингу повинен супроводжуватись:
1.	Описом проблеми, яку вирішує даний метод;
2.	Кодом до і після застосування методу рефакторингу;
3.	Поясненням переваг використаного методу. 
Студенту потрібно ознайомитися з основними методами рефакторингу, описаними у книзі Мартіна Фаулера, і вибрати три методи, які найкраще підходять для рефакторингу його коду.
Необхідно узгодити вибір методів із викладачем, щоб уникнути повторення методів серед студентів.
Кожен метод повинен супроводжуватися конкретним прикладом з коду студента. Це можуть бути фрагменти з курсових, лабораторних або інших проєктів, написаних на будь-якій мові програмування.
Студент повинен надати докладні пояснення щодо кожного методу, підготувати слайди або текстову доповідь для презентації власного аналізу та представити свою доповідь викладачу.
 
3 ОПИС ВИКОНАНОЇ РОБОТИ

3.1 Вибір методів рефакторингу
Було обрано такі три методи рефакторингу:
-	Replace Nested Conditional with Guard Clauses; 
-	Replace Parameter with Method; 
-	Hide Method.
Ці методи були обрані, здебільшого, з огляду на найбільш часті помилки у коді, написаному в попередніх навчальних проєктах.

3.2 Важливість рефакторингу
Рефакторинг підвищує читабельність, знижує складність і сприяє швидшому додаванню нових функцій. Регулярний рефакторинг зменшує ризик виникнення помилок при внесенні змін, покращує тестованість та архітектурну стійкість системи, тобто робить код набагато чистішим [2]. Основна ідея – покращити внутрішній дизайн працюючого коду, зберігши його функціональність.

3.3	Replace nested conditional with guard clauses
3.3.1	Опис методу
Основна суть цього методу спрямована на те, щоб позбутися глибокої вкладеності  if-else. За Мартіном Фаулером існує два типи if-else: один з них має обидві гілки нормальної поведінки, а другий – має одну гілку незвичайної поведінки, або виключення. Перевірки другого типу можуть призвести до дуже великої вкладеності, саме тому їх треба замінити на "захисні умови" (Guard Clauses) — це швидкі перевірки на початку, які негайно виходять з функції, якщо зустрічають помилку або нетиповий випадок.

3.3.2	Приклад проблемного коду
Погляньмо на метод registerUser з контролера платформи бронювання [3]. Цей метод має обробити багато сценаріїв: нового користувача, користувача, що існує, заблокованого, не верифікованого тощо. Цей код є яскравим прикладом неправильного використання умов другого типу та має низку проблем, які потребують вирішення. Основними проблемами є те, що через відступи код стає складним для візуального сприйняття, та те, що основна корисна дія знаходиться аж на третьому рівні вкладеності.
 
1  // Контролер реєстрації (registerUser)
2  const registerUser = asyncHandler(async (req, res) => {
3    // ... (отримання даних з req.body) ...
4  
5    if (email && name) { // <-- 1-й рівень
6      let user = await User.findOne(...);
7  
8      if (!user) {
9        // ... (Логіка створення нового юзера) ...
10       res.status(201).json(...);
11     } else { 
12       
13       if (!user.isBlocked) { // <-- 2-й рівень
15         
16         if (!user.isEmailVerified) { // <-- 3-й рівень
17           
18           // ... (багато коду для повторної верифікації) ...
19           res.status(200).json(...);
20 
21         } else { // <-- else 3-го рівня
22           throw new Error('Користувач вже верифікований.');
23         }
24 
25       } else { // <-- else 2-го рівня
26         throw new Error('Акаунт заблоковано.');
27       }
28     }
29 
30   } else { // <-- else 1-го рівня
31     throw new Error("Заповніть обов'язкові поля");
32   }
33 });

3.3.3	Вирішення проблеми
Щоб вирішити проблему необхідно пройти по всім основним крокам нашого методу рефакторингу:
1)	Знаходимо зовнішню умову, яка веде до "нетипового" випадку, у нашому випадку це найперший else (де !email || !name).
2)	Інвертуємо цю умову і ставимо її на початку функції, тим самим роблячи її захисною.
3)	У блоці цієї умови одразу робимо throw new Error.
4)	Повторюємо для наступних вкладених умов.
 
У результаті ми повинні отримати значно кращий код, який працює так само. Тепер код читається не як заплутане дерево та ми одразу бачимо всі "погані" сценарії, а також додати нову перевірку тепер значно простіше.

1  const registerUser = asyncHandler(async (req, res) => {
2    // ... (отримання даних з req.body) ...
3  
4    // ЗАХИСНА УМОВА 1 (Валідація)
5    if (!email || !name) {
6      throw new Error("Заповніть обов'язкові поля");
7    }
8  
9    let user = await User.findOne(...);
10 
11   if (user) {
12     // ЗАХИСНА УМОВА 2 (Блокування)
13     if (user.isBlocked) {
14       throw new Error('Акаунт заблоковано.');
15     }
16
17      // ЗАХИСНА УМОВА 3 (Вже верифікований?)
18      if (user.isEmailVerified) {
19        throw new Error('Користувач вже верифікований.');
20      }
21 
22      // ... (код для повторної верифікації) ...
23      res.status(200).json(...);
24     return; // Важливий вихід
25    }
26 
27   // ... (Логіка створення нового юзера) ...
28   res.status(201).json(...);
29 });

3.4	Hide delegate
3.4.1	Опис методу
Основна ідея цього методу рефакторингу спрямована на покращення дотримання принципу інкапсуляції.
Проблема полягає в тому, що клієнт знає забагато про внутрішній устрій “Сервера”. Він напряму залежить від класу “Делегата”. Для вирішення ми створюємо метод на “Сервері”, який всередині себе викликає вже метод “Делегата”, який потрібен клієнту.

3.4.2	Приклад проблемного коду
Розгляньмо клас Applications List із програми для автоматичного зарахування абітурієнтів [3]. Цей клас представляє список об’єктів класу заявки. Його робота – завантажувати з файлу та зберігати всі заявки абітурієнтів. Цей код є яскравим прикладом недотримання принципу інкапсуляції та створення крихтого коду з високою зав’язаністю клієнта на внутрішній реалізації списку.
 
1  // 1. Клас "Сервер": ApplicationsList
2  public class ApplicationsList
3  {
4      // "Делегат" (внутрішня структура даних) є публічним.
5      public List<Application> Applications { get; set; }
6  
7      public ApplicationsList()
8      {
9          // Конструктор завантажує дані у цей публічний список
10         this.Applications = new List<Application>();
11         LoadFromFile();
12         // ...
13     }
14     
15     private void LoadFromFile()
16     {
17         // ... (логіка читання з JSON і заповнення this.Applications) 18 ...
19     }
20 }


1  // 2. "Клієнтський код" (де-небудь у проекті)
2  var appList = new ApplicationsList();
3  
4  // Ми залазимо всередину appList і беремо його внутрішній список
5  var app = appList.Applications.FirstOrDefault(a => a.Id == "some-id");
6  
7  // Логіка пошуку розмазана по клієнтах
8  int count = appList.Applications.Count(a => a.ApplicationStatus == "Допущено");

3.4.3	Вирішення проблеми
Щоб вирішити проблему необхідно пройти по всім основним крокам нашого методу рефакторингу:
1)	Для кожного методу "Делегата", який потрібен клієнту, створюємо простий метод-посередник на "Сервері", у нашому випадку це два методи для пошуку заявки за айді та підрахування кількості допущених до конкурсу заяв.
2)	Змінюємо клієнтський код, щоб він викликав новий метод на "Сервері". Робимо це для кожного місця порушення інкапсуляції.
3)	Коли жоден клієнт більше не звертається до "Делегата" напряму, ми робимо гетер "Делегата" приватним або видаляємо його, як ми і зробили зі списком заявок.
У результаті ми повинні отримати значно кращий код, який працює так само. Тепер клієнт нічого не знає про внутрішній устрій класу, який може вільно змінюватися без необхідності редагувати клієнтський код.

1  // 1. Клас "Сервер": ApplicationsList - тепер інкапсульований
2  public class ApplicationsList
3  {
4      // делегат приховано
5      // Тепер це внутрішня деталь реалізації.
6      private List<Application> _applications;
7  
8      public ApplicationsList()
9      {
10         this._applications = new List<Application>();
11         LoadFromFile();
12         // ...
13     }
14 
15     // ... (приватний метод LoadFromFile) ...
16     
17     // Метод-делегат 1
18     public Application GetApplicationById(string id)
19     {
20         // Логіка пошуку живе всередині
21         return this._applications.FirstOrDefault(a => a.Id == id);
22     }
23 
24     // Метод-делегат 2
25     public int CountApplicationsByStatus(string status)
26     {
27         return this._applications.Count(a => a.ApplicationStatus == status);
28     }
29 }


1  // 2. Клієнтський код - тепер чистий
2  var appList = new ApplicationsList();
3  
4  // Клієнт викликає чистий, семантичний метод.
5  // Йому байдуже, як appList це робить.
6  var app = appList.GetApplicationById("some-id");
7  
8  // Логіка централізована і не дублюється
9  int count = appList.CountApplicationsByStatus("Допущено");


3.5	Replace parameter with method / query
3.5.1	Опис методу
Цей метод рефакторингу має на меті спростити список параметрів функції. Той, хто викликає функцію (caller), змушений виконувати зайву роботу, і це є проблемою. Ми видаляємо параметр, значення якого функція може так само легко отримати самостійно. В результаті інтерфейс функції стає чистішим. Вона приймає лише ті дані, які справді є унікальними точками варіативності, а не похідними.

3.5.2	Приклад проблемного коду
Для прикладу візьмімо контролер з тієї ж програми для зарахування абітурієнтів. Метод Recommend [5] рекомендує студентів на бюджет, але він приймає аргумент у вигляді списку абітурієнтів ззовні, з клієнтської частини. Тобто у клієнтській частині виконується абсолютно зайва робота створення та передачі списку, який не буде там використовуватися. І це є основною проблемою, яка потребує вирішення.
 
1  // 1. Код, що викликається (Callee)
2  public static bool Recommend(
3      List<Models.Application> applications, // проблемний параметр
4      string courseCode, 
5      int count, 
6      string recommendType)
7  {
8      // ... (код курсу) ...
9  
10     if (recommendType == "Бюджет")
11     {
12         // ...
13         // Параметр 'applications' активно використовується
14         int currentBudgetRecommendations = applications.Count(a => ...);
15         // ...
16         var eligibleApplications = applications.Where(a => ...);
17         // ...
18     }
19     // ... (аналогічно для "Контракт") ...
20     return true;
21 }


1  // 2. Код, що викликає (Caller)
2  // Цей код змушений виконувати зайву роботу:
3  
4  // 1. Створити репозиторій
5  var appList = new ApplicationsList();
6  
7  // 2. Дістати з нього список (порушуючи інкапсуляцію)
8  var allApps = appList.Applications; // (або appList.GetAllApplications())
9  
10 // 3. І тільки потім викликати метод
11 RecommendingApplications.Recommend(allApps, "121", 5, "Бюджет");

3.5.3	Вирішення проблеми
Щоб вирішити проблему необхідно пройти по всім основним крокам нашого методу рефакторингу:
1)	Якщо логіка отримання параметра складна, спочатку виокремлюємо її в новий метод-"запит" (query). У нас вже є логіка всередині класу ListApplications завдяки попередньому рефактиронгу, тому можемо лише додати рядок його виклику всередину нашого методу.
2)	Всередині нашої функції замінюємо всі згадки параметра на виклик цього нового методу. Цього теж робити в нашому випадку не треба, оскільки ми лише створимо змінну на початку, щоб не створювати новий список кожен раз.
3)	Після тестів видаляємо параметр із сигнатури функції.
4)	Оновлюємо всі місця виклику, прибравши передачу зайвого параметра.
У результаті ми повинні отримати значно кращий код, який працює так само. Сигнатура методу Recommend тепер відображає, які дані їй насправді потрібні. З коду, що викликає, зникає обов'язок передавати параметр та виконувати зайву роботу.

1  // 1. Код, що викликається (Callee) - тепер самостійний
2  public static bool Recommend(
3      // параметр видалено
4      string courseCode, 
5      int count, 
6      string recommendType)
7  {
8      // запит додано сюди
9      // Метод сам отримує дані, які йому потрібні.
10     var appList = new ApplicationsList();
11    var applications = appList.GetAllApplications(); 
12
13     var course = new CoursesList().Courses.FirstOrDefault(c => c.Code == courseCode);
14     // ... (решта коду методу) ...
15 
16     if (recommendType == "Бюджет")
17     {
18         // ...
19         // Код продовжує працювати з локальною змінною 'applications'
20         int currentBudgetRecommendations = applications.Count(a => ...);
21         // ...
22         var eligibleApplications = applications.Where(a => ...);
23         // ...
24     }
25     // ...
26 }


1  // 2. Код, що викликає (Caller) - тепер дуже простий
2  // Код UI-форми став чистим, простим і сфокусованим.
3  // Йому не потрібно нічого знати про 'ApplicationsList'.
4  
5  RecommendingApplications.Recommend("121", 5, "Бюджет");
 
ВИСНОВКИ

У результаті виконання практичного заняття було на конкретних прикладах здобуто та закріплено навички з рефакторингу коду за допомогою методів, описаних у книзі Мартіна Фаулера «Refactoring. Improving the Design of Existing Code». 
Було виконано рефакторинг власного коду, написаного раніше у ході виконання курсових та інших навчальних проєктів. На основі цього було створено презентацію (Додаток Б), яка має на меті закріпити власні знання, а також поділитися здобутою інформацією з іншими.
Виконана робота показала, що рефакторинг – це не лише про красу. Це про створення надійного, гнучкого та легкого у підтримці коду. Ми зменшили технічний борг і зробили так, щоб з нашими проєктами було легко працювати в майбутньому. 
ВИКОРИСТАНІ ДЖЕРЕЛА

1.	Fowler M. Refactoring: Improving the Design of Existing Code. Addison-Wesley Professional, 2018. 448 с.
2.	Robert C. Martin — Clean Code: A Handbook of Agile Software Craftsmanship. URL: https://github.com/Gatjuat-Wicteat-Riek/clean-code-book (дата звернення: 04.11.2025).
3.	Гарнат А. С. та ін. Проєктний Практикум “Сервіс бронювання житла Apartica”: authController.js. URL: https://github.com/alinaharnat/Apartica-app/blob/main/backend/controllers/authController.js (дата звернення 04.11.2025).
4.	Вус А. М. Курсове проєктування “Зарахування Абітурієнтів”: ApplicationsList.cs. URL: https://github.com/APAXIC/ApplicantsEnrollment/blob/master/ApplicantsEnrollment/Models/ApplicationsList.cs (дата звернення 04.11.2025).
5.	Вус А. М. Курсове проєктування “Зарахування Абітурієнтів”: RecommendingApplications.cs. URL: https://github.com/APAXIC/ApplicantsEnrollment/blob/master/ApplicantsEnrollment/Controllers/RecommendingApplications.cs (дата звернення 04.11.2025).
  
ДОДАТОК А

Відеозапис

Відеозапис доповіді: https://youtu.be/huK2Yypd6PI

Хронологічний опис відеозапису:
0:00 Вступ
0:12 Чому рефакторинг це важливо?
0:34 Replace Nested Contitional with Guarded Clauses
1:26 Приклад коду для першого методу
2:04 Вирішення проблеми першим методом
2:47 Hide Delegate
3:27 Приклад коду для другого методу
4:06 Вирішення проблеми другим методом
5:11 Replace Parameter with Method / Query
5:54 Приклад коду для третього методу
6:22 Вирішення проблеми третімметодом
7:32 Висновки
8:06 Перелік джерел
 
Додаток Б

Слайди презентації

 
Рисунок Б.1 – Титульний слайд

 
Рисунок Б.2 – Чому рефакторинг це важливо

 
Рисунок Б.3 – Replace nested conditional with guard causes

 
Рисунок Б.4 – Приклад коду для першого методу

 
Рисунок Б.5 – Вирішення проблем коду за першим методом

 
Рисунок Б.6 – Hide delegate

 
Рисунок Б.7 – Приклад коду для другого методу

 
Рисунок Б.8 – Вирішення проблем коду за другим методом

 
Рисунок Б.9 – Replace parameter with method / query

 
Рисунок Б.10 – Приклад коду для третього методу


 
Рисунок Б.11 – Вирішення проблем коду за третім методом


 
Рисунок Б.12 – Висновки

 
Рисунок Б.13 – Використані джерела

